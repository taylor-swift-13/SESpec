

#!/usr/bin/env python3
"""
Collector class for collecting correct specifications and problems,
and outputting them in JSON format to the Jsons folder.
"""

import json
import os
from typing import Dict, List, Any, Optional
from datetime import datetime
from config import LLMConfig
from llm import *


class Collector:
    """Collector class for managing specification collection and JSON output."""
    
    def __init__(self, jsons_dir: str = "VectorDB/Jsons"):
        """
        Initialize the Collector.
        
        Args:
            jsons_dir: Directory path for storing JSON files
        """
        self.jsons_dir = jsons_dir
        self.ensure_jsons_dir()
        self.llm_config = LLMConfig(api_model='gpt-4o-mini')
        self.llm = Chatbot(self.llm_config)
    
    def ensure_jsons_dir(self) -> None:
        """Ensure the Jsons directory exists."""
        os.makedirs(self.jsons_dir, exist_ok=True)
    
    def collect_specification(self, 
                            input_code: str,
                            output_code: str) -> Dict[str, Any]:
        """
        Collect a specification entry with only input and output.
        Other fields (name, category, type, value, explanation) will be generated by LLM.
        
        Args:
            input_code: Input C code with placeholders
            output_code: Output C code with complete specifications
            
        Returns:
            Dictionary containing the specification data
        """
        return {
            "input": input_code,
            "output": output_code
        }
    
    def generate_specification_fields(self, 
                                    input_code: str, 
                                    output_code: str) -> Dict[str, str]:
        """
        Generate name, category, type, value, and explanation fields using LLM.
        Type can only be "list" or "array".
        Category can only be "loop invariant" or "function".
        
        Args:
            input_code: Input C code with placeholders
            output_code: Output C code with complete specifications
            
        Returns:
            Dictionary containing generated fields
        """
        # Call LLM to generate all fields using separate questions
        try:
            # Question 1: Extract function name
            name_prompt = f"""Analyze the following C code and extract the function name:

INPUT CODE:
{input_code}

What is the name of the main function? Respond with only the function name, nothing else."""

            name_response = self.llm.chat(name_prompt)
            function_name = name_response.strip()
            
            # Question 2: Determine category
            category_prompt = f"""Analyze the following C code and determine the category:

OUTPUT CODE:
{output_code}


Does this code contain only loop invariant? 
- If YES, respond with: "loop invariant"
- If NO, respond with: "function"

Respond with only one of these two options: "loop invariant" or "function"."""

            category_response = self.llm.chat(category_prompt)
            category = category_response.strip().lower()
            if category not in ["loop invariant", "function"]:
                category = "loop invariant"  # default
            
            # Question 3: Determine type
            type_prompt = f"""Analyze the following C code and determine the data structure type:

INPUT CODE:
{input_code}

OUTPUT CODE:
{output_code}

What data structure does this code primarily work with?
- If it works with no data structures, respond with: "numeric"
- If it works with closed data structures, respond with: "closed"
- If it works with recursive data structures (like linked list), respond with: "recursive"
- If it works with arrays (int* array, array indexing), respond with: "array"

Respond with only one of these two options: "list" or "array" or "numeric" or "closed" or "recursive"."""

            type_response = self.llm.chat(type_prompt)
            spec_type = type_response.strip().lower()
            if spec_type not in ["list", "array", "numeric", "closed", "recursive"]:
                spec_type = "numeric"  # default
            
            # Question 4: Generate value description
            value_prompt = f"""Analyze the following C code and describe what it does:

INPUT CODE:
{input_code}

Provide a brief description of what this C function does."""

            value_response = self.llm.chat(value_prompt)
            value_description = value_response.strip()
            
            # Question 5: Generate explanation
            explanation_prompt = f"""Analyze the following C code and explain why the specifications are correct:

OUTPUT CODE:
{output_code}

Provide a brief explanation of why the specifications (preconditions, postconditions, loop invariants) are correct for this code. Explain how they ensure the correctness of the function In the order of program execution."""

            explanation_response = self.llm.chat(explanation_prompt)
            explanation = explanation_response.strip()
            
            return {
                "name": function_name,
                "category": category,
                "type": spec_type,
                "value": value_description,
                "explanation": explanation
            }
            
        except Exception as e:
            print(f"LLM generation failed: {e}")
            print("Falling back to heuristic generation...")
            
            return None


    
    def collect_specification_with_generation(self, 
                                            input_code: str,
                                            output_code: str) -> Dict[str, Any]:
        """
        Collect a specification entry and generate all other fields automatically.
        
        Args:
            input_code: Input C code with placeholders
            output_code: Output C code with complete specifications
            
        Returns:
            Dictionary containing the complete specification data
        """
        # Generate all fields automatically
        generated_fields = self.generate_specification_fields(input_code, output_code)
        
        # Combine with input and output
        if generated_fields is None:
            return None
        else:
            specification = {
                "name": generated_fields["name"],
                "category": generated_fields["category"],
                "type": generated_fields["type"],
                "input": input_code,
                "output": output_code,
                "value": generated_fields["value"],
                "explanation": generated_fields["explanation"]
            }
        
        return specification
    
    def save_to_json(self, 
                    specifications: List[Dict[str, Any]], 
                    filename: Optional[str] = None) -> str:
        """
        Save specifications to a JSON file.
        
        Args:
            specifications: List of specification dictionaries
            filename: Optional filename. If None, uses timestamp
            
        Returns:
            Path to the saved JSON file
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"specifications_{timestamp}.json"
        
        if not filename.endswith('.json'):
            filename += '.json'
        
        filepath = os.path.join(self.jsons_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(specifications, f, indent=4, ensure_ascii=False)
        
        print(f"Specifications saved to: {filepath}")
        return filepath
    
    def load_from_json(self, filename: str) -> List[Dict[str, Any]]:
        """
        Load specifications from a JSON file.
        
        Args:
            filename: Name of the JSON file
            
        Returns:
            List of specification dictionaries
        """
        filepath = os.path.join(self.jsons_dir, filename)
        
        with open(filepath, 'r', encoding='utf-8') as f:
            specifications = json.load(f)
        
        return specifications
    
    def input_to_file(self, 
                     specification: Dict[str, Any], 
                     filename: str) -> str:
        """
        Input a specification directly to a specific file.
        
        Args:
            specification: Specification dictionary to input
            filename: Name of the target file (with or without .json extension)
            
        Returns:
            Path to the file where specification was saved
        """
        if not filename.endswith('.json'):
            filename += '.json'
        
        filepath = os.path.join(self.jsons_dir, filename)
        
        # Save specification as a single-item list
        specifications = [specification]
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(specifications, f, indent=4, ensure_ascii=False)
        
        print(f"Specification '{specification['name']}' saved to {filepath}")
        return filepath

    
    def add_specification_to_file(self, 
                                 input_code: str,
                                 output_code: str,
                                 filename: str) -> str:
        """
        Add a specification to a specific JSON file using append mode.
        Only input and output are required, all other fields are generated automatically.
        
        Args:
            input_code: Input C code with placeholders
            output_code: Output C code with complete specifications
            filename: Name of the target file (with or without .json extension)
            
        Returns:
            Path to the file where specification was added
        """
        if not filename.endswith('.json'):
            filename += '.json'
        
        filepath = os.path.join(self.jsons_dir, filename)
        
        # Generate complete specification automatically
        specification = self.collect_specification_with_generation(input_code, output_code)
        
        if specification is None:
            print("Failed to generate specification fields")
            return None
        
        # Handle different file states
        if not os.path.exists(filepath):
            # File doesn't exist - create it with the specification
            print(f"Creating new file: {filepath}")
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump([specification], f, indent=4, ensure_ascii=False)
        else:
            # File exists - check if it's empty or has content
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read().strip()
                
                if not content:
                    # File is empty - write the specification as a list
                    print(f"File is empty, writing specification: {filepath}")
                    with open(filepath, 'w', encoding='utf-8') as f:
                        json.dump([specification], f, indent=4, ensure_ascii=False)
                else:
                    # File has content - try to load and append
                    try:
                        with open(filepath, 'r', encoding='utf-8') as f:
                            existing_specs = json.load(f)
                        
                        if not isinstance(existing_specs, list):
                            # If it's not a list, wrap it in a list
                            existing_specs = [existing_specs]
                        
                        # Append new specification
                        existing_specs.append(specification)
                        
                        # Save back to file
                        with open(filepath, 'w', encoding='utf-8') as f:
                            json.dump(existing_specs, f, indent=4, ensure_ascii=False)
                        
                        print(f"Appended specification to existing file: {filepath}")
                        
                    except json.JSONDecodeError:
                        # If JSON parsing fails, create a new file with the specification
                        print(f"Invalid JSON in file, creating new file: {filepath}")
                        with open(filepath, 'w', encoding='utf-8') as f:
                            json.dump([specification], f, indent=4, ensure_ascii=False)
                            
            except Exception as e:
                print(f"Error reading file {filepath}: {e}")
                # If any error occurs, create a new file
                with open(filepath, 'w', encoding='utf-8') as f:
                    json.dump([specification], f, indent=4, ensure_ascii=False)
        
        print(f"Specification '{specification['name']}' added to {filepath}")
        print(f"Generated fields: name='{specification['name']}', type='{specification['type']}', category='{specification['category']}'")
        return filepath
    
    

def test_collector():
    """Test function for Collector class with simple examples."""
    print("=== Testing Collector Class ===")
    
    # Initialize collector
    collector = Collector()
    
    # Test case 1: Simple addition function
    print("\n1. Testing simple addition function...")
    input_code1 = """int add(int a, int b) {
    return a + b;
}"""
    output_code1 = """/*@ 
requires true;
ensures \\result == a + b;
*/
int add(int a, int b) {
    return a + b;
}"""
    
    result1 = collector.add_specification_to_file(input_code1, output_code1, "test.json")
    print(f"Result 1: {result1}")
    
    # Test case 2: Simple multiplication function
    print("\n2. Testing simple multiplication function...")
    input_code2 = """int multiply(int a, int b) {
    return a * b;
}"""
    output_code2 = """/*@ 
requires true;
ensures \\result == a * b;
*/
int multiply(int a, int b) {
    return a * b;
}"""
    
    result2 = collector.add_specification_to_file(input_code2, output_code2, "test.json")
    print(f"Result 2: {result2}")
    
    # Test case 4: Simple max function
    print("\n3. Testing simple max function...")
    input_code3 = """int max(int a, int b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}"""
    output_code3 = """/*@ 
requires true;
ensures \\result >= a && \\result >= b;
ensures \\result == a || \\result == b;
*/
int max(int a, int b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}"""
    
    result3 = collector.add_specification_to_file(input_code3,output_code3, "test.json")
    print(f"Result 3: {result3}")
    
    
    print("\n=== Test completed ===")


def main():
    """Example usage of the Collector class."""
    test_collector()


if __name__ == "__main__":
    main()
